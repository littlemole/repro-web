<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>repro-web: Modern C++ for web development. With Promises. And Coroutines.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">repro-web
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Modern C++ for web development. With Promises. And Coroutines. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>reactive non-blocking c++ web development with promises. coroutines optional.</p>
<h1>disclaimer</h1>
<p>this is a private academic study on how future c++ apis for the web could look like, with an emphasis on promise/coroutine support.</p>
<blockquote class="doxtable">
<p>this software is not considered production ready. use only on your own risk - you have been warned! </p>
</blockquote>
<p>for production usage relying on production-ready stacks, have a look at <a href="https://github.com/CppCon/CppCon2017/tree/master/Demos/Using%20IncludeOS%20to%20Write%20Fast%20and%20Secure%20Web%20Applications">Lukas Bergdoll</a></p>
<h1>doxygen documentation</h1>
<p><a href="https://littlemole.github.io/repro-web/index.html">doxydocs</a></p>
<h1>motivation</h1>
<p>study to explore modern c++' fitness for modern, server side web development.</p>
<h1>target</h1>
<p>from a developer perspective, allow for server side web development at a level of convenience par to Node.js or Java Servlets.</p>
<h1>requirements</h1>
<ul>
<li>nonblocking io</li>
<li>single thread model</li>
<li>no callback hell thanks to promises (and - optionally with clang++ or msvc - coroutine sugar)</li>
<li>declarative http routing</li>
<li>http filters</li>
<li>support for JSON</li>
<li>support for templating</li>
<li>Dependency Injection</li>
<li>websockets</li>
<li>i18n support</li>
<li>ssi includes in templates</li>
<li>automagic JSON serialization for REST APIs</li>
<li>support for HTTP,HTTPS,HTTP2</li>
</ul>
<h1>dependencies</h1>
<ul>
<li><a href="http://github.com/littlemole/repro">repro</a> exposes the fundamental Promise abstraction to wrap async io</li>
<li><a href="http://github.com/littlemole/prio">prio</a> gives basic asio primitives using promises, backed by either <a href="http://libevent.org/">libevent</a> or <a href="https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio.html">boost-asio</a></li>
<li><a href="http://github.com/littlemole/prio-http">prio-http</a> adds support for HTTP, HTTPS, HTTP2, further backed by <a href="https://zlib.net/">zlib</a> and <a href="https://nghttp2.org/">libnghttp2</a></li>
<li><a href="http://github.com/littlemole/cryptoneat">cryptoneat</a> adds support for basic crypto backed by <a href="https://www.openssl.org/">OpenSSL</a></li>
<li><a href="http://github.com/littlemole/diy">diy</a> dependency injection for c++</li>
<li><a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp</a> for JSON support</li>
<li><a href="https://github.com/kainjow/Mustache">mustache</a> for templating</li>
</ul>
<h1>3d party dependencies</h1>
<ul>
<li>libevent or boost_asio for main event loop and async IO</li>
<li>gtest for testing</li>
<li>jsoncpp for JSON support</li>
<li>nghttp2 for HTTP/2 support</li>
<li>openssl for SSL/TLS and crypto</li>
<li>zlib for compression</li>
</ul>
<h1>available middleware</h1>
<ul>
<li><a href="http://github.com/littlemole/repro-curl">repro-curl</a> for making HTTP client calls serverside</li>
<li><a href="http://github.com/littlemole/repro-redis">repro-redis</a> access to Redis key-value store</li>
<li><a href="http://github.com/littlemole/repro-mysql">repro-mysql</a> access MySQL databases</li>
<li><a href="http://github.com/littlemole/repro-sqlite">repro-sqlite</a> access SQlite databases (mainly intended for dev and prototyping)</li>
</ul>
<h1>unit and integration testing</h1>
<p>using <a href="https://github.com/google/googletest">gtest</a></p>
<h1>hello world</h1>
<p>main.cpp </p><div class="fragment"><div class="line">{c++}</div><div class="line">#include &quot;reproweb/ctrl/controller.h&quot;</div><div class="line">#include &quot;reproweb/web_webserver.h&quot;</div><div class="line">#include &quot;reproweb/view/tpl.h&quot;</div><div class="line"></div><div class="line">using namespace prio;</div><div class="line">using namespace reproweb;</div><div class="line"></div><div class="line">class Controller</div><div class="line">{</div><div class="line">public:</div><div class="line">    Controller()</div><div class="line">    {</div><div class="line">        templates_.load(&quot;/view/&quot;);</div><div class="line">    }</div><div class="line"></div><div class="line">    void index( Request&amp; req, Response&amp; res)</div><div class="line">    {</div><div class="line">        Json::Value viewModel(Json::objectValue);</div><div class="line">        viewModel[&quot;greeting&quot;] = &quot;Hello World&quot;;</div><div class="line"></div><div class="line">        res</div><div class="line">        .body(templates_.render(&quot;index&quot;, viewModel ))</div><div class="line">        .contentType(&quot;text/html&quot;)</div><div class="line">        .ok()</div><div class="line">        .flush();</div><div class="line">    }</div><div class="line"></div><div class="line">private:</div><div class="line">    reproweb::TplStore templates_;</div><div class="line">};</div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    init();</div><div class="line"></div><div class="line">    WebApplicationContext ctx </div><div class="line">    {</div><div class="line">        GET( &quot;/&quot;, &amp;Controller::index),</div><div class="line"></div><div class="line">        singleton&lt;Controller()&gt;()</div><div class="line">    };  </div><div class="line"></div><div class="line">    WebServer server(ctx);</div><div class="line">    server.listen(9876);</div><div class="line"></div><div class="line">    theLoop().run();</div><div class="line"></div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p>index.tpl: </p><div class="fragment"><div class="line">&lt;body&gt;</div><div class="line">&lt;head&gt;&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1&gt;{{greeting}}&lt;/h1&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></div><!-- fragment --><p> compile with </p><div class="fragment"><div class="line">g++ main.cpp -std=c++17 $(pkg-config --libs --cflags reproweb jsoncpp libnghttp2  openssl zlib libevent_pthreads)</div></div><!-- fragment --><p> see examples/readme/ for code.</p>
<h1>going async</h1>
<p>now extend the example by simulating making an async service call using libcurl. actually we will just make an http call to our own webserver that servers a static json file at /api/service.json.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">...</div><div class="line"></div><div class="line">class Model </div><div class="line">{</div><div class="line">public:</div><div class="line"></div><div class="line">    Model()</div><div class="line">        :service_endpoint(&quot;http://localhost:9876/api/service.json&quot;)</div><div class="line">    {}</div><div class="line"></div><div class="line">    Future&lt;Json::Value&gt; fetch_greeting()</div><div class="line">    {</div><div class="line">        auto p = promise&lt;Json::Value&gt;();</div><div class="line"></div><div class="line">        request req(service_endpoint);</div><div class="line"></div><div class="line">        fetch(req)</div><div class="line">        .then([p](response res)</div><div class="line">        {</div><div class="line">            p.resolve(JSON::parse(res.content()));</div><div class="line">        })</div><div class="line">        .otherwise(reject(p));</div><div class="line"></div><div class="line">        return p.future();</div><div class="line">    }</div><div class="line"></div><div class="line">private:</div><div class="line">    Url service_endpoint;</div><div class="line">};</div><div class="line"></div><div class="line">class Controller</div><div class="line">{</div><div class="line">public:</div><div class="line"></div><div class="line">    Controller(std::shared_ptr&lt;Model&gt; m, std::shared_ptr&lt;View&gt; v)</div><div class="line">        : model(m), view(v)</div><div class="line">    {}</div><div class="line"></div><div class="line">    void index( Request&amp; req, Response&amp; res)</div><div class="line">    {</div><div class="line">        model-&gt;fetch_greeting()</div><div class="line">        .then([this,&amp;res](Json::Value greeting)</div><div class="line">        {</div><div class="line">            view-&gt;render_greeting(res,greeting);</div><div class="line">        })</div><div class="line">        .otherwise([this,&amp;res](const std::exception&amp; ex)</div><div class="line">        {</div><div class="line">            view-&gt;render_error(res,ex.what());</div><div class="line">        });        </div><div class="line">    }</div><div class="line"></div><div class="line">private:</div><div class="line">    std::shared_ptr&lt;Model&gt; model;</div><div class="line">    std::shared_ptr&lt;View&gt; view;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">{</div><div class="line">    ...</div><div class="line"></div><div class="line">    WebApplicationContext ctx </div><div class="line">    {</div><div class="line">        GET( &quot;/&quot;, &amp;Controller::index),</div><div class="line"></div><div class="line">        static_content(&quot;/htdocs/&quot;,&quot;/etc/mime.types&quot;),</div><div class="line"></div><div class="line">        diy::singleton&lt;Model()&gt;(),</div><div class="line">        diy::singleton&lt;View()&gt;(),</div><div class="line">        diy::singleton&lt;Controller(Model,View)&gt;()</div><div class="line">    };</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>compile with </p><div class="fragment"><div class="line">g++ main.cpp -std=c++17 $(pkg-config --libs --cflags reproweb reprocurl jsoncpp libnghttp2  openssl zlib libevent_pthreads libcurl)</div></div><!-- fragment --><p>full source in examples/mvc/main.cpp</p>
<h1>coroutines</h1>
<p>using a compiler with support for coroutines TS, this becomes:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">...</div><div class="line"></div><div class="line">class Model </div><div class="line">{</div><div class="line">public:</div><div class="line"></div><div class="line">    Model()</div><div class="line">        :service_endpoint(&quot;http://localhost:9876/api/service.json&quot;)</div><div class="line">    {}</div><div class="line"></div><div class="line">    Future&lt;Json::Value&gt; fetch_greeting()</div><div class="line">    {</div><div class="line">        request req(service_endpoint);</div><div class="line"></div><div class="line">        response res = co_await fetch(req);</div><div class="line"></div><div class="line">        co_return JSON::parse(res.content());</div><div class="line">    }</div><div class="line"></div><div class="line">private:</div><div class="line">    Url service_endpoint;</div><div class="line">};</div><div class="line"></div><div class="line">class Controller</div><div class="line">{</div><div class="line">public:</div><div class="line"></div><div class="line">    Controller(std::shared_ptr&lt;Model&gt; m, std::shared_ptr&lt;View&gt; v)</div><div class="line">        : model(m), view(v)</div><div class="line">    {}</div><div class="line"></div><div class="line">    Async index( Request&amp; req, Response&amp; res)</div><div class="line">    {</div><div class="line">        try</div><div class="line">        {</div><div class="line">            Json::Value greeting = co_await model-&gt;fetch_greeting();</div><div class="line">            view-&gt;render_greeting(res,greeting);</div><div class="line">        }</div><div class="line">        catch(const std::exception&amp; ex)</div><div class="line">        {        </div><div class="line">            view-&gt;render_error(res,ex.what());</div><div class="line">        }        </div><div class="line">    }</div><div class="line"></div><div class="line">private:</div><div class="line">    std::shared_ptr&lt;Model&gt; model;</div><div class="line">    std::shared_ptr&lt;View&gt; view;</div><div class="line">};</div><div class="line"></div><div class="line">...</div></div><!-- fragment --><h1>installation</h1>
<h2>docker</h2>
<p>assuming a recent installation of docker and docker-compose:</p>
<div class="fragment"><div class="line">git clone https://github.com/littlemole/devenv</div><div class="line">cd devenv</div><div class="line">make image CXX=g++</div><div class="line">make image CXX=clang++</div><div class="line">cd ..</div><div class="line">git clone https://github.com/littlemole/repro-web</div><div class="line">cd repro-web</div><div class="line">make image CXX=g++</div><div class="line">make image CXX=clang++</div></div><!-- fragment --><p> at this point do <em>make run</em> to start the image with a bash shell and tinker around.</p>
<p>or look at the examples.</p>
<p>### docker with clang++ and thread sanitizer </p><div class="fragment"><div class="line">make image CXX=clang++ TS=-fsanitize=thread</div></div><!-- fragment --><div class="fragment"><div class="line">cd examples/hello_world</div><div class="line">make up</div></div><!-- fragment --><p> point your browser to <a href="https://localhost:9876/">https://localhost:9876/</a> once the container is running.</p>
<h2>linux</h2>
<p>reproduce steps as in <a href="https://github.com/littlemole/devenv/blob/master/Dockerfile">devenv</a> Dockerfile</p>
<p>this roughly boils down to</p><ul>
<li>install std c++ dev packages</li>
<li>install 3dparty C linraries</li>
<li>install 3dparty C++ libraries (gtest and jsoncpp) and compile with g++ or clang++ respectively</li>
<li>fetch and install these static libs from <a href="https://github.com/littlemole">github.com/littlemole</a><ul>
<li>cryptoneat</li>
<li>diy</li>
<li>repro</li>
<li>prio</li>
<li>prio-http</li>
<li>repro-web</li>
</ul>
</li>
<li>optional middleware:<ul>
<li>repro-curl</li>
<li>repro-mysql</li>
<li>repro-sqlite</li>
<li>repro-redis</li>
</ul>
</li>
</ul>
<p>use classic <em>make &amp;&amp; make test &amp;&amp; sudo make install</em> to provision the static libs.</p>
<h2>windows</h2>
<p>windows installation via private clone of vcpkg:</p>
<div class="fragment"><div class="line">git clone https://github.com/littlemole/vcpkg</div><div class="line">cd vcpkg</div><div class="line">git checkout promise</div><div class="line">bootstrap-vcpkg.bat</div><div class="line">.\vcpkg install reproweb</div><div class="line">cd ..</div></div><!-- fragment --><p>to play with examples, use CMAKE to generate vcproject files, ie:</p>
<div class="fragment"><div class="line">git clone https://github.com/littlemole/repro-web</div><div class="line">cd repro-web\examples\hello_world</div><div class="line">mkdir debug</div><div class="line">cd debug</div><div class="line">cmake .. -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=..\..\..\..\vcpkg\scripts\buildsystems\vcpkg.cmake</div></div><!-- fragment --><p> change CMAKE_BUILD_TYPE to Release for a Release build.</p>
<p>either now open the generated *.sln file in Visual Studio or use msbuild.</p>
<div class="fragment"><div class="line">msbuild ALL_BUILD.vcxproj </div></div><!-- fragment --><p>or for a release build:</p>
<div class="fragment"><div class="line">msbuild ALL_BUILD.vcxproj /p:Configuration=Release</div></div><!-- fragment --><p>Separate setups for Debug and Release exist for easier vcpkg integration.</p><ul>
<li>Debug config: both Debug and Release builds will kinda work out of the box, but if you check Release Mode library dependencies in VS you'll see that it picks some debug libs instead the release ones, so you want to manually fix these if you want to have a simgle config that supports both Release and Debug</li>
<li>Release config: only Release build will work out of the box, but Debug Mode library dependencies will picks some release libs instead the debug ones, so you have to manually fix these if you want to have a simgle config that supports both Release and Debug</li>
</ul>
<h2>about library and examples debug builds</h2>
<p>all libraries and examples do the debug build with -DMOL_PROMISE_DEBUG which conditionally enables counting of outstanding core entities, useful to track memory leaks during library development.</p>
<p>with -DMOL_PROMISE_DEBUG defined your app has to setup the tracked counters as in <a href="https://github.com/littlemole/repro-web/blob/master/t/test.h">test.h</a>.</p>
<p>LINUX: for normal application development just link to release libs and do a debug build of your app only without defining -DMOL_PROMISE_DEBUG WIN32: due to the link-time incompat of debug and release builds there is currently no win32 setup to support debug builds without -DMOL_PROMISE_DEBUG. this is a limitation of the current implementation. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
